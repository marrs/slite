Slite
=====

A PAC framework written in Javascript.

FEATURES

  * Caches any data retrieved to improve subsequent look-up.
  * Uses a RESTful interface internally as well as externally.

DEPENDENCIES

  * Node.js
  * Expresso (for unit testing)

LIMITATIONS (Not stuff that just hasn't been implemented yet)

  * Reads templates syncronously
    - Enables page to be built through nested functions but may be slower
	  than using an event driven procedure.  Might investigate how much / if
	  speed improves with an event driven model after v1.0 is complete.

HOW IT WORKS

Every reusable element of a page (called a "component" in Slite, or a "partial"
in other frameworks) implements a full PAC model.  Components can be made up of
smaller components (compound components) by calling them through their
controllers. In this sense, one can think of the final web page as being a
component: it is fundamentally no different from any other component.

	--Model--

Slite expects to be provided with a data model.  It does not, and will not
ever, provide any tools for retrieving data from a database.  Slite sticks to
the UNIX principle of doing one job and doing it well.  If you wish to use an
ORM, you will have to provide your own.

	--View--

Multiple views can provide different data formats for a component (e.g. html,
xml, json).  Views should only ever contain component templates and never any
logic or data. (They may contain helpers for looping etc.)

Views are mapped directly to controller actions.  For example, an HTML template
serving the shop.index action will be found in the shop/index.html file.  A
JSON template would be in shop/index.json, and so on.

	--Controller--

  * binds data to a template (view) and returns result.
  * RESTful in nature.
  * can make requests of other controllers.
  * option to overload with other methods may be added later if it can be done
    safely.
  
  Get:
    * 1st arg: the path to the controller for the requested component.
    * 2nd arg: (optional)
		* an alternative view for the controller to format;
		* an empty object (no 3rd arg possible);
		* an object containing query data.
    * 3rd arg: (optional)
		* an object containing query data (if 2nd arg was a view);
		* an alternative view (if 2nd arg was an object).

    Examples: (SUBJECT TO CHANGE)
      get('/path/to/resource');  // returns default view
      get('/path/to/resource', {});  // returns the model directly
                                    // (useful for json encoding)
      get('/path/to/resource', '.xml');  // returns as xml
      get('/path/to/resource', '/path/to/some/other/view.html');
                                        // returns a custom view (as html).

  Post:
    * 1st arg: a request object (containing request method, data, etc).
    * 2nd arg: callback function(s) to execute on response.
    or...
    * 1st arg: a URL path for the component being requested.
    * 2nd arg: object containing data to post
    * 3rd arg: callback function(s) to execute on response.

    Examples: (SUBJECT TO CHANGE)
      post('/path/to/component', data_object, callback);
      post(request_object, callback);
      post(request_object, {
        success: function(response) { /* success callback */},
        failure: function(response) { /* failure callback */},
      });
     
	Slite posts should be manually routed to the originating component for
    handling.  If there are multiple components on a page requiring queries,
	these can be namespaced using the '?foo[bar]=baz' notation.
